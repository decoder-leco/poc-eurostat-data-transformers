---
import { getCollection } from 'astro:content';
const typeDocEntries = await getCollection('api-docs');

/**
 * pnpm add -D markdown-it highlight.js
 */
import markdownit from 'markdown-it'
import hljs from 'highlight.js' // https://highlightjs.org

/*
// commonmark mode
const md = markdownit('commonmark')

// default mode
const md = markdownit()

// enable everything
const md = markdownit({
  html: true,
  linkify: true,
  typographer: true
})

*/


// full options list (defaults)
const md = markdownit({
  // Enable HTML tags in source
  html:         true,

  // Use '/' to close single tags (<br />).
  // This is only for full CommonMark compatibility.
  xhtmlOut:     false,

  // Convert '\n' in paragraphs into <br>
  breaks:       false,

  // CSS language prefix for fenced blocks. Can be
  // useful for external highlighters.
  langPrefix:   'language-',

  // Autoconvert URL-like text to links
  linkify:      true,

  // Enable some language-neutral replacement + quotes beautification
  // For the full list of replacements, see https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.mjs
  typographer:  true,

  // Double + single quotes replacement pairs, when typographer enabled,
  // and smartquotes on. Could be either a String or an Array.
  //
  // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
  // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
  quotes: '“”‘’',

  // Highlighter function. Should return escaped HTML,
  // or '' if the source string is not changed and should be escaped externally.
  // If result starts with <pre... internal wrapper is skipped.
  // highlight: function (/*str, lang*/) { return ''; }
  highlight: function (str: any, lang: any) {
    if (lang && hljs.getLanguage(lang)) {
      try {
        return hljs.highlight(str, { language: lang }).value;
      } catch (__) {}
    }

    return ''; // use external default escaping
  }
});

/*
const result = md.render('# markdown-it rulezz!');
*/
---
{typeDocEntries.map(typeDocEntry => {
  /**
  let readme: string = ``
  for (let i = 0; typeDocEntry.data.readme.length; i++) {

  }
   */
  return (
  <h1>
      
    <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg dark:bg-gray-600 dark:text-gray-100 dark:border-gray-500">
      {//typeDocEntry.data.name
        typeDocEntry.data.packageName
      }  
    </kbd>
    
  </h1>
  <hr/>

)})}


{typeDocEntries[0].data.readme.map((readmeEntry: { kind: string, text: string}, index: number) => {

    
    let renderedHtml = md.render(readmeEntry.text);
    console.log(`renderedHtml`, String(renderedHtml))
    
    return (
          {//typeDocEntry.data.name
            renderedHtml
          }

    )
})}